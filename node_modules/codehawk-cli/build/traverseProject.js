"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFileContents = exports.walkSync = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const slash_1 = __importDefault(require("slash"));
const utils_1 = require("./utils");
const analyze_1 = require("./analyze");
// dir can be string or dir
const walkSync = (dir, options) => {
    const fileList = [];
    const items = fs.readdirSync(dir);
    const parsedEntities = items.map((filename) => ({
        filename,
        fullPath: path.join(dir, filename),
        entity: (0, utils_1.getFsEntity)(path.join(dir, filename)),
        relativeDir: (0, slash_1.default)(dir).replace((0, slash_1.default)(process.cwd()), ''),
    }));
    const visibleEntities = parsedEntities.filter((item) => (0, utils_1.shouldSeeEntity)({
        filename: item.filename,
        dir,
        fullPath: item.fullPath,
        entity: item.entity,
        options,
        relativeDir: item.relativeDir,
    }));
    visibleEntities.forEach((item) => {
        const { fullPath, filename, entity, relativeDir } = item;
        const baseParsedEntity = {
            fullPath: (0, slash_1.default)(item.fullPath),
            filename,
            shouldAnalyze: (0, utils_1.shouldAnalyzeEntity)({
                entity,
                filename,
                fullPath,
                options,
                relativeDir,
            }),
        };
        if (entity.isDirectory()) {
            fileList.push({
                ...baseParsedEntity,
                type: 'dir',
                files: (0, exports.walkSync)(fullPath, options),
            });
        }
        else {
            fileList.push({
                ...baseParsedEntity,
                path: (0, slash_1.default)(dir),
                type: 'file',
            });
        }
    });
    // Sort by directories first, then alphabetically
    // Required for windows consistency, helps for display
    const sorted = fileList.sort((a, b) => {
        if (a.type === b.type) {
            return a.filename.toLowerCase() > b.filename.toLowerCase() ? 1 : -1;
        }
        return a.type > b.type ? 1 : -1;
    });
    return sorted;
};
exports.walkSync = walkSync;
const getFileContents = (fullPath, enableFlow) => {
    // see https://stackoverflow.com/questions/190852/how-can-i-get-file-extensions-with-javascript/12900504#12900504
    const filename = path.basename(fullPath);
    const extension = path.extname(filename);
    const contents = fs.readFileSync(fullPath, 'utf8');
    // TypeScript support
    const isTypescript = extension === '.ts' || extension === '.tsx';
    return (0, analyze_1.transpileFileSource)(contents, extension, isTypescript, enableFlow);
};
exports.getFileContents = getFileContents;
