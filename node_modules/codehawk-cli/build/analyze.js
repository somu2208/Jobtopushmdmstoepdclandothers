"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.analyzeFile = exports.calculateComplexity = exports.transpileFileSource = void 0;
const core_1 = require("@babel/core");
const flow_remove_types_1 = __importDefault(require("flow-remove-types"));
const escomplex_1 = __importDefault(require("./reporters/escomplex"));
const transpileFileSource = (sourceCode, fileExtension, isTypescript, enableFlow) => {
    let contents = sourceCode;
    if (isTypescript) {
        const transformed = (0, core_1.transformSync)(contents, {
            plugins: [
                [
                    '@babel/plugin-transform-typescript',
                    {
                        isTSX: fileExtension === '.tsx',
                    },
                ],
            ],
        });
        contents = transformed.code || '';
    }
    else {
        // Assume no other static type systems exist
        // Stripping flow types should be safe, even if it's not strictly flow
        contents = enableFlow
            ? (0, flow_remove_types_1.default)(contents, { pretty: true }).toString()
            : contents;
    }
    return contents;
};
exports.transpileFileSource = transpileFileSource;
const calculateComplexity = (sourceCode, fileExtension, isTypescript, enableFlow) => {
    return (0, escomplex_1.default)((0, exports.transpileFileSource)(sourceCode, fileExtension, isTypescript, enableFlow));
};
exports.calculateComplexity = calculateComplexity;
const analyzeFile = (dirPath, file, projectCoverage) => {
    // Handle cases where a file was intended to be analyzed, but the source could not be parsed
    if (!file.rawSource) {
        return null;
    }
    let report = null;
    const relativeFilePath = `${file.path}/${file.filename}`.replace(dirPath, '');
    const coverageData = projectCoverage.find((c) => c.path === relativeFilePath);
    let fileCoverage = '0';
    if (coverageData) {
        // Coverage can have a bug where 0 things have 100% coverage
        const linesPct = coverageData.coverage.lines.total === 0
            ? 0
            : coverageData.coverage.lines.pct;
        const fnPct = coverageData.coverage.functions.total === 0
            ? 0
            : coverageData.coverage.functions.pct;
        const stmntPct = coverageData.coverage.statements.total === 0
            ? 0
            : coverageData.coverage.statements.pct;
        const branchPct = coverageData.coverage.branches.total === 0
            ? 0
            : coverageData.coverage.branches.pct;
        // Average the four coverage types.
        fileCoverage = ((linesPct + fnPct + stmntPct + branchPct) / 4).toFixed(2);
    }
    const trimmed = file.rawSource.trim();
    try {
        const complexityReport = (0, escomplex_1.default)(trimmed);
        if (complexityReport) {
            report = {
                ...complexityReport,
                coverage: fileCoverage,
            };
        }
    }
    catch (e) {
        console.error(`[codehawk-cli] Unable to analyze file "${file.path}/${file.filename}", skipping`);
        // if (NODE_ENV !== 'production') {
        //     // Print out  what is attempting to be evaluated
        //     // Exposes bugs such as flow-remove-types not working correctly
        //     // Note: if you see flow types in here, they have not been stripped correctly
        //     console.error(e)
        //     console.log('\n\n')
        //     console.error(trimmed)
        //     console.log('\n\n')
        // }
        // No clear API for capturing a SyntaxError, also we don't know if it'll always be that.
    }
    return report;
};
exports.analyzeFile = analyzeFile;
