"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConfiguration = exports.buildOptions = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const errors_1 = require("./consts/errors");
const baseOptions = {
    badgesDirectory: {
        type: 'stringArray',
        default: ['/generated'],
        replaceDefault: true,
    },
    enableFlow: {
        type: 'boolean',
        default: false,
        replaceDefault: true,
    },
    extensions: {
        type: 'stringArray',
        default: ['.js', '.jsx', '.ts', '.tsx'],
        replaceDefault: false,
    },
    excludeDirectories: {
        type: 'stringArray',
        default: ['/dist', '/bin', '/build'],
        replaceDefault: true,
    },
    excludeExact: {
        type: 'stringArray',
        default: [],
        replaceDefault: true,
    },
    excludeFilenames: {
        type: 'stringArray',
        default: ['.d.ts', '.min.js', '.bundle.js'],
        replaceDefault: false,
    },
    skipDirectories: {
        type: 'stringArray',
        default: ['/node_modules', '/flow-typed', '/coverage'],
        replaceDefault: false,
    },
    minimumThreshold: {
        type: 'number',
        default: 10,
        replaceDefault: true,
    },
    cliOutputLimit: {
        type: 'number',
        default: 25,
        replaceDefault: true,
    },
};
const injectOptionValues = ({ existingOptions, optionKey, val, }) => {
    let err;
    const newOptions = { ...existingOptions };
    switch (optionKey) {
        case 'enableFlow':
            newOptions[optionKey] = val;
            break;
        case 'badgesDirectory':
        case 'excludeDirectories':
        case 'excludeExact':
        case 'excludeFilenames':
        case 'extensions':
        case 'skipDirectories':
            newOptions[optionKey] = val;
            break;
        case 'minimumThreshold':
        case 'cliOutputLimit':
            newOptions[optionKey] = parseInt(val, 10);
            break;
        default:
            // Print a friendly error but also allow the upstream generic handling to kick in
            err = `[codehawk-cli] Unknown option "${optionKey}" is not supported`;
            console.warn(err);
            throw new Error(err);
    }
    return newOptions;
};
const buildOptions = (projectOptions) => {
    let assembledOptions = {};
    Object.keys(baseOptions).forEach((optionKey) => {
        const option = baseOptions[optionKey];
        let val = option.default;
        if (projectOptions[optionKey]) {
            // Project options can either be added to the defaults, or replace them.
            if (option.replaceDefault) {
                // Mutate options by replacing (we assume project config is valid!)
                val = projectOptions[optionKey];
            }
            else {
                // Mutate options by mixing in project options to defaults
                val =
                    option.type === 'stringArray' && Array.isArray(val)
                        ? val.concat(projectOptions[optionKey])
                        : (val = projectOptions[optionKey]);
            }
        }
        assembledOptions = injectOptionValues({
            existingOptions: assembledOptions,
            optionKey,
            val,
        });
    });
    return assembledOptions;
};
exports.buildOptions = buildOptions;
const getConfiguration = (rootDirectory) => {
    try {
        if ((0, fs_1.existsSync)((0, path_1.resolve)(`${rootDirectory}/codehawk.json`))) {
            const configContents = (0, fs_1.readFileSync)((0, path_1.resolve)(`${rootDirectory}/codehawk.json`), 'utf8');
            return JSON.parse(configContents);
        }
        const packageConfig = (0, fs_1.readFileSync)((0, path_1.resolve)(`${rootDirectory}/package.json`), 'utf-8');
        const parsedPackageConfig = JSON.parse(packageConfig);
        if ('codehawk' in parsedPackageConfig) {
            return parsedPackageConfig.codehawk;
        }
    }
    catch (e) {
        console.log(e);
    }
    throw new Error(errors_1.NO_CONFIGURATION_FOUND);
};
exports.getConfiguration = getConfiguration;
