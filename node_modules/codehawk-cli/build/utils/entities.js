"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.shouldAnalyzeEntity = exports.shouldSeeEntity = exports.getFsEntity = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const slash_1 = __importDefault(require("slash"));
const is_dotfile_1 = __importDefault(require("is-dotfile"));
const is_dotdir_1 = __importDefault(require("is-dotdir"));
const blocklist_1 = require("./blocklist");
const shouldSkipDir = (relativeDir, skipDirectories) => {
    for (let i = 0; i < skipDirectories.length; i += 1) {
        if (relativeDir.startsWith(skipDirectories[i])) {
            return true;
        }
    }
    return false;
};
const isDotEntity = (fullPath) => {
    const dotDir = (0, is_dotdir_1.default)(fullPath) || (0, is_dotdir_1.default)((0, slash_1.default)(fullPath));
    const dotFile = (0, is_dotfile_1.default)(fullPath) || (0, is_dotfile_1.default)((0, slash_1.default)(fullPath));
    return dotDir || dotFile;
};
const getFsEntity = (fullPath) => {
    let dirent = null;
    try {
        dirent = fs.statSync(fullPath);
    }
    catch (e) {
        // Ingore the error
        // Scenarios this catches: symlinks or otherwise inaccessible directories
    }
    return dirent;
};
exports.getFsEntity = getFsEntity;
// Should the dir/file show at all in results?
const shouldSeeEntity = ({ dir, entity, filename, fullPath, options, relativeDir, }) => {
    // Is a symlink, or other un-readable entity?
    if (!entity) {
        return false;
    }
    // Exclude dot directories/files
    if (isDotEntity(fullPath)) {
        return false;
    }
    // Is a directory?
    if (entity.isDirectory()) {
        return true;
    }
    // Is codehawk config?
    if (filename === 'codehawk.json') {
        return false;
    }
    // Should the directory be completely skipped according to user options?
    if (shouldSkipDir(relativeDir, options.skipDirectories)) {
        return false;
    }
    return true;
};
exports.shouldSeeEntity = shouldSeeEntity;
// Should the dir/file have complexity analysis run?
const shouldAnalyzeEntity = ({ entity, filename, fullPath, options, relativeDir, }) => {
    const extension = path.extname(filename);
    // Is a symlink, or other un-readable entity?
    if (!entity) {
        return false;
    }
    // Exclude dot directories/files
    if (isDotEntity(fullPath)) {
        return false;
    }
    // Is a directory?
    if (entity.isDirectory()) {
        return true;
    }
    // Is the extension included in the options?
    if (!options.extensions.includes(extension)) {
        return false;
    }
    // Is the path/filename excluded by user options?
    if ((0, blocklist_1.isBlocklisted)(relativeDir, filename, options)) {
        return false;
    }
    return true;
};
exports.shouldAnalyzeEntity = shouldAnalyzeEntity;
