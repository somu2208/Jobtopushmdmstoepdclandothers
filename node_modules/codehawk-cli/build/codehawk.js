"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateBadge = exports.analyzeProject = exports.calculateComplexity = void 0;
const path = __importStar(require("path"));
const slash_1 = __importDefault(require("slash"));
const coverage_1 = require("./coverage");
const analyze_1 = require("./analyze");
Object.defineProperty(exports, "calculateComplexity", { enumerable: true, get: function () { return analyze_1.calculateComplexity; } });
const traverseProject_1 = require("./traverseProject");
const dependencies_1 = require("./dependencies");
const options_1 = require("./options");
const badge_1 = require("./badge");
Object.defineProperty(exports, "generateBadge", { enumerable: true, get: function () { return badge_1.generateBadge; } });
const utils_1 = require("./utils");
const cwd = (0, slash_1.default)(process.cwd());
const analyzeProject = (rawPath, isCliContext) => {
    // When using CLI, execute from the cwd rather than a relative path
    const actualRoot = isCliContext ? cwd : rawPath;
    const projectOptions = (0, options_1.getConfiguration)(actualRoot);
    let options = {};
    try {
        options = (0, options_1.buildOptions)(projectOptions);
    }
    catch (e) {
        if (isCliContext) {
            console.error('[codehawk-cli] Unable to parse codehawk options - please ensure you have provided correct values');
            process.exit(1);
        }
        else {
            throw new Error('[codehawk-cli] Unable to parse codehawk options - please ensure you have provided correct values');
        }
    }
    const dirPath = path.resolve(`${actualRoot}/`);
    const projectCoverage = (0, coverage_1.getCoverage)(dirPath);
    const addComplexityToFile = (file) => {
        let fileContents;
        try {
            if (file.shouldAnalyze) {
                fileContents = (0, traverseProject_1.getFileContents)(file.fullPath, options.enableFlow);
            }
        }
        catch (error) {
            console.error(`[codehawk-cli] Unable to parse "${file.path}/${file.filename}", skipping`);
        }
        const complexityReport = !file.shouldAnalyze
            ? null
            : (0, analyze_1.analyzeFile)(dirPath, {
                path: file.path,
                filename: file.filename,
                rawSource: fileContents,
            }, projectCoverage);
        return {
            ...file,
            complexityReport,
            fullPath: file.fullPath.replace(cwd, ''),
            path: file.path.replace(cwd, ''),
        };
    };
    const addComplexityToEntities = (entities) => entities.map((entity) => {
        if (entity.type === 'dir') {
            return {
                ...entity,
                files: addComplexityToEntities(entity.files),
                fullPath: entity.fullPath.replace(cwd, ''),
            };
        }
        return addComplexityToFile(entity);
    });
    const addDependencyCountToFile = (projectDeps, file) => ({
        ...file,
        timesDependedOn: (0, dependencies_1.getTimesDependedOn)(projectDeps, file.fullPath),
    });
    const addDependencyCounts = (projectDeps, entities) => entities.map((entity) => {
        if (entity.type === 'dir') {
            return {
                ...entity,
                files: addDependencyCounts(projectDeps, entity.files),
            };
        }
        return addDependencyCountToFile(projectDeps, entity);
    });
    // First run of all files: generate complexity & coverage metrics
    const entities = (0, traverseProject_1.walkSync)(dirPath, options);
    const firstRunResults = addComplexityToEntities(entities);
    // Second run: generate timesDependedOn (can only be calculated after first run)
    const projectDeps = (0, dependencies_1.getProjectDeps)(firstRunResults);
    const secondRunResults = addDependencyCounts(projectDeps, firstRunResults);
    const resultsAsList = (0, utils_1.getResultsAsList)(secondRunResults);
    const summary = (0, utils_1.getResultsSummary)(resultsAsList);
    // When in a CLI context, exit if the worst case fails to meet the minimum threshold
    if (isCliContext && summary.worst < options.minimumThreshold) {
        console.error(`[codehawk-cli] Worst case (${summary.worst}) was below the minimum threshold (${options.minimumThreshold})`);
        process.exit(1);
    }
    return {
        options,
        summary,
        resultsList: resultsAsList,
        fullResultsTree: secondRunResults,
    };
};
exports.analyzeProject = analyzeProject;
